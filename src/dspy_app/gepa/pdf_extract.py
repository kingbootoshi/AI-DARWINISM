"""
Utilities to extract GEPA prompts from the official paper PDF (Appendix I).
"""

from __future__ import annotations

import re
from typing import Dict

try:  # PyMuPDF (fitz)
    import fitz  # type: ignore
except Exception:  # pragma: no cover - optional dependency at runtime
    fitz = None  # type: ignore[assignment]


GEPA_SECTION_HEADER = r"I\.\s*1\s+HOTPOTQA,\s+GPT-4\.1\s+MINI"
MODULE_HEADER_PATTERNS = {
    "create_query_hop2": r"HotpotQA GPT-4\.1 Mini create_query_hop2\.predict",
    "final_answer": r"HotpotQA GPT-4\.1 Mini final_answer\.predict",
    "summarize1": r"HotpotQA GPT-4\.1 Mini summarize1\.predict",
    "summarize2": r"HotpotQA GPT-4\.1 Mini summarize2\.predict",
}
PROMPT_BOX_ANCHOR = r"GEPA Prompt generated by config GEPA:"


def extract_prompts_from_pdf(pdf_path: str) -> Dict[str, str]:
    """Extract Hotpot/GPT-4.1 Mini module prompts from the paper PDF.

    Returns
    -------
    Dict[str, str]
        Mapping of module name -> instruction string.
    """
    if fitz is None:
        raise RuntimeError("PyMuPDF (fitz) not installed. `pip install PyMuPDF`")

    doc = fitz.open(pdf_path)
    text = "\n".join(page.get_text("text") for page in doc)
    doc.close()

    m = re.search(GEPA_SECTION_HEADER, text, flags=re.IGNORECASE)
    if not m:
        raise RuntimeError("Couldn't locate 'I.1 HOTPOTQA, GPT-4.1 MINI' in the PDF. Check the file.")
    start = m.start()
    m2 = re.search(r"I\.\s*2\s+HOTPOTQA,\s+Qwen3", text[start:], flags=re.IGNORECASE)
    end = start + (m2.start() if m2 else len(text))
    sub = text[start:end]

    def grab_for(module_key: str) -> str:
        head_pat = MODULE_HEADER_PATTERNS[module_key]
        mH = re.search(head_pat, sub, flags=re.IGNORECASE)
        if not mH:
            raise RuntimeError(f"Couldn't find header for {module_key}")
        after = sub[mH.end():]
        mA = re.search(PROMPT_BOX_ANCHOR, after, flags=re.IGNORECASE)
        if not mA:
            raise RuntimeError(f"Couldn't find GEPA prompt anchor for {module_key}")
        after2 = after[mA.end():]
        stops = [re.search(pat, after2, flags=re.IGNORECASE) for pat in MODULE_HEADER_PATTERNS.values()]
        stops = [s for s in stops if s]
        stop_idx = min(s.start() for s in stops) if stops else len(after2)
        prompt = after2[:stop_idx].strip()
        prompt = re.sub(r"\n{2,}", "\n", prompt)
        return prompt.strip()

    prompts = {k: grab_for(k) for k in MODULE_HEADER_PATTERNS.keys()}
    return prompts


